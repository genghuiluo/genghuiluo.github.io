---
layout: post
title: 《高性能MySQL》读书笔记
date: 2017-03-19 11:25:17 +0800
categories: mysql
---

## 1.MySQL 逻辑架构

![]({{ site.url }}/assets/high_performance_mysql_1.jpg)

最上层服务，大多数基于网络的C/S的工具或者服务都有类似的架构。比如连接处理，授权认证，安全等等。

第二层架构，大多数MySQL的核心服务功能都在这一层，包括查询解析/分析/优化/缓存/所有内置函数（日期/时间/数序/加密），所有跨存储引擎的功能都在这一层实现：存储过程/触发器/视图等。

第三层包含了存储引擎(InnoDB,XtraDB...)，负责数据的存储和提取。和Linux下各种文件系统一样，每种存储引擎都有各自的优劣势。
服务器通过API与存储引擎进行通信。这些接口屏蔽了不同引擎之间的差异，对上层的查询过程透明。
存储引擎包含十几个底层函数，用于执行例如“开始一个事务“ 或者 “根据主键提取一行记录“等操作。

> InnoDB是一个例外，它会解析外键定义，因为MySQL服务器本身没有实现该功能。

但是存储引擎不会解析SQL，不同的存储引擎之间也不会相互通信，只是简单的响应上层服务器的请求。

### 连接

每个客户端连接都会在服务器进程里拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行。服务器会缓存线程，因此不需要为每一个新建的连接创造或者销毁线程。

> MySQL >=5.5, 提供了一个API，支持线程池(Thread-Pooling)插件，可以使用池中少量的线程来服务大量的连接。

连接认证基于用户名，原始主机信息，和密码。如果使用了安全套接字（SSL）的方式连接，还可以使用X.509证书认证。一旦连接成功，服务器会继续验证是否具有执行某个查询的权限。

### 查询

MySQL会解析查询，并创建解析树（内部数据结构），然后对其进行各种优化，包括重写查询/决定表的读取顺序/选择合适的索引等。用户可以通过特殊关键字提示（hint）优化器，影响它的决策过程。
也可以请求优化器解释（explain）如何进行优化决策的，便于重构查询和schema，修改相关配置。

优化器并不关心表使用的是什么存储引擎,但是存储引擎对于优化查询是有影响的。
优化器会请求存储引擎提供容量或某个具体操作的开销，以及表的统计信息等。

对于SELECT，在解析查询前，服务器会先检查查询缓存（Query Cache），如果发现对应的查询，不会在解析-> 优化 -> 执行，而是直接返回查询缓存中的结果集。

### MVCC multiversion concurrency control

- 共享锁（shared lock）/ 读锁
- 排它锁（exclusive lock）/ 写锁

锁粒度，任何时候，在给定的资源上，锁定的数据量越小，则系统的并发程度越高。

锁策略，在锁的开销和数据的安全性之间寻求平衡。

- table lock, 表锁(MySQL最基本的锁策略，并且是开销最小的策略）
- row-level lock, 行级锁

每种MySQL引擎都可以实现自己的锁粒度和锁策略，分别支持不同的应用场景。

InnoDB MVCC 通过在每行记录后面保存两个隐藏的列来实现（创建时间+过期(删除)时间，系统版本号）

### 事务

一组原子性SQL查询。事务内语句要么全部执行成功，要么全部执行失败。

``` sql
START TRANSACTION;

COMMIT;

ROLLBACK;
```

ACID，一个兼容ACID的数据库系统，需要做很多复杂但可能用户并没有察觉到的工作（硬件开销） 
- 原子性：不可分割的最小工作单元
- 一致性：数据库总是从一个一致性的状态转换为另一个一致性状态
- 隔离性：一个事务做的修改在未提交之前，对其他事务不可见
- 持久性：一旦事务提交，修改永久保存在数据库中

对于一些不需要事务的查询类应用，选择一个非事务型的存储引擎，可以获得更高的性能。
即使存储引擎不支持事务，也可以通过`LOCK TABLES`语句为应用提供一定程度的保护。

[隔离级别](http://blog.genghuiluo.cn/mysql/2017/03/11/Innodb%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E9%94%81%E7%9A%84%E5%85%B3%E7%B3%BB.html)

死锁，两个或多个事务，在同一资源上相互占用，并锁定对方占用的资源，从而导致恶性循环。

两重原因：
- 真正的数据冲突
- 存储引擎的实现方式（锁的行为和顺序和存储引擎相关）

死锁检测/死锁超时机制
（InnoDB存储引擎，检测到死锁的循环依赖会立即返回错误，或者超时后，将持有最少行级排它锁的事务进行回滚。

事务日志，预写式日式（Write-Ahead Logging），修改数据需要写两次磁盘：
1. 修改内存拷贝，再把该修改行为记录倒持久在硬盘上的事务日志中（追加的方式，顺训I/O，减少磁头移动）
2. 内存中修改的数据在后台周期性的刷回磁盘

#### MySQL中的事务

两种事务型存储引擎：InnoDB, NDB Cluster
第三方支持事务的存储引擎：XtraDB, PBXT

MySQL默认采用AUTOCOMMIT模式（如果不显示的开始一个事务，每个查询都被当作一个事务执行COMMIT）
``` mysql
mysql> show variables like '%autocommit%';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set (0.02 sec)

mysql> set autocommit=1; -- 1 on, 0 off
Query OK, 0 rows affected (0.00 sec)
```

> 修改AUTOCOMMIT对于非事务型的表（MyISAM/内存表）不会有任何影响。这类表没有COMMIT/ROLLBACK的概念（相当于一直处在AUTOCOMMIT启用的模式）。
另外还有一些命令在执行前会强制COMMIT。比如，DDL中的ALTER TABLE/LOCK TABLES。

MySQL可以通过`SET SESSION TRANSACTION ISOLATION LEVEL [READ COMMITED|...]`来设置隔离级别，InnoDB支持四种ANSI隔离级别。

显示/隐式锁定
1. InnoDB采用两阶段锁协议，事务执行的过程中根据隔离级别的需要自动加锁（隐式），COMMIT/ROLLBACK才会释放所有的锁（同一时刻）
2. `SELECT ... LOCK IN SHARE MODE` ，`SELECT ... FOR UPDATE`
    > `LOCK/UNLOCK TABLES` 是在服务器层面实现，和存储引擎无关

#### MySQL 存储引擎

在文件系统中，每个数据库保存为`datadir`下的子目录，创建表时，会在子目录下创建`.frm`文件保存表的定义。（Windows大小写不敏感，类UNIX敏感）

不同的存储引擎保存数据和索引的方式是不同的，但表的定义是在MySQL服务层统一处理。

```
mysql> show variables like '%datadir%';
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| datadir       | /var/lib/mysql/ |
+---------------+-----------------+

ls -l /var/lib/mysql/test
total 127536
-rw-r----- 1 mysql mysql       65 Aug 11  2016 db.opt
-rw-r----- 1 mysql mysql     8802 Dec  8 23:09 douban_rent_post_sh.frm
-rw-r----- 1 mysql mysql 67108864 Dec 12 23:54 douban_rent_post_sh.ibd
-rw-r----- 1 mysql mysql     8652 Dec 29 14:13 my_public_ip.frm
-rw-r----- 1 mysql mysql    98304 Mar 18 11:54 my_public_ip.ibd
-rw-r----- 1 mysql mysql     8948 Feb  3 22:48 weibo_posts.frm
-rw-r----- 1 mysql mysql 62914560 Mar 14 15:01 weibo_posts.ibd
-rw-r----- 1 mysql mysql     8716 Mar  9 13:15 weibo_realtimehot.frm
-rw-r----- 1 mysql mysql   409600 Mar 18 12:00 weibo_realtimehot.ibd
```

``` mysql
mysql> use mysql;
mysql> show table status like 'user' \G -- (\G) Send command to mysql server, display result vertically
*************************** 1. row ***************************
           Name: user
         Engine: MyISAM
        Version: 10
     Row_format: Dynamic
           Rows: 4
 Avg_row_length: 128
    Data_length: 512
Max_data_length: 281474976710655
   Index_length: 4096
      Data_free: 0
 Auto_increment: NULL
    Create_time: 2017-01-24 16:41:47
    Update_time: 2017-01-24 16:41:47
     Check_time: NULL
      Collation: utf8_bin
       Checksum: NULL
 Create_options: 
        Comment: Users and global privileges
1 row in set (0.00 sec)
```

InnoDB是MySQL默认事务型引擎，用来处理大量短期（short-lived）事务。

MyISAM，包括全文索引，压缩，空间函数（GIS）等，但是不支持事务，行级锁，自动崩溃恢复。
将表存储在两个文件：数据文件（.MYD）和索引文件（.MYI），根据表的定义决定Row_format，可存储的最大行数受限于磁盘空间或者操作系统单个文件最大尺寸。
```sql
CHECK TABLE mytable
REPAIR TABLE mytable -- 可能丢失数据，和InnoDB的自动崩溃恢复不同
-- myisamchk
```
即使是BLOB和TEXT也可以基于前500个字符(max_sort_length)创建索引。
延迟更新索引键，`DELAY_KEY_WRITE`，内存中的键缓冲区（in-memory key buffer），提高写入性能。 
压缩表(无法修改)，`myisampack`，支持索引（只读），减少I/O和磁盘占用空间

其他内建存储引擎：
- Archive 引擎，只支持INSERT/SELECT，缓存所有的写利用zlib对插入的行进行压缩（比MyISAM更少的I/O）；但是每次SELECT都要执行全表扫描；适合日志和数据采集类应用
- Blackhole 引擎，不存储，只记录表日志，用于复制数据备份数据库
- CSV 引擎，将CSV文件作为表处理，不支持索引，适合数据交换
- Federated 引擎（FederatedX in MariaDB），访问其他MySQL服务器的代理
- Memory 引擎，Memory表（HEAP表，保存在内存中，重启后数据丢失），适合lookup/mapping表，缓存周期性聚合数据，保存数据分析的中间结果
    > 临时表（CREATE TEMPORARY TABLE），默认使用Memory表，如果太大，转为MyISAM表
- Merge 引擎，引入分区后废弃
- NDB 集群引擎，MySQL cluster

#### 第三方存储引擎
插件式存储引擎API
- OLTP 类
    - XtraDB（Percona）
    - PBXT
    - TokuDB，大数据存储引擎，拥有很高的压缩比 
    - RethinkDB
- 列式存储
    - Infobright，OLAP/DW，数据高度压缩，按照块进行排序，每块都对应一组元数据（准索引，不支持索引），处理查询时，访问元数据可决定是否跳过此块
    - InfiniDB，分布式查询
- 社区(慎用。。）
    - Aria，解决了崩溃安全恢复问题的MyISAM
    - Groonga，全文索引
    - OQGraph，支持图操作（比如查找两点之间的最短路径）
    - Q4M，内部实现队列
    - SphinxSE，为Sphinx全文索引搜索服务器提供了SQL接口
    - Spider，数据切分成不同的分区
    - VPForMySQL，垂直分区

> 除非需要用到某些InnoDB不具备的特性，并且没有其他办法可以替代，否则都应该优先选择InnoDB引擎。

选择引擎要考虑的要素：
1. 事务
2. 备份(在线热备份，InnoDB是基本选择）
3. 崩溃恢复
4. 特有特性

#### 转换表的引擎

1. `ALTER TABLE my_table ENGINE = InnoDB;`，适用于任何存储引擎，但是需要执行很长时间（原表加锁，复制数据到新表）
2. `mysqldump` 导入导出，修改CREATE TABLE的存储引擎
3. CREATE & SELECT
    ``` sql
    CREATE TABLE innodb_table LIKE myisam_table;
    ALTER TABLE innodb_table ENGINE = InnoDB;
    INSERT INTO innodb_table SELECT * FROM myisam_table; -- 如果数据量大，可以分批插入
    ```

> pt-online-schema-change(基于Facebook的在线schema变更技术）

## 2.MySQL 基准测试

sysbench

## 3.服务器性能

## 4.schema,数据类型优化

- 更小的通常更好,如果只需存储0～200，tinyint unsigned更好
- 简单就好，整型比字符(字符集/校对规则）操作代价低
    1. 日期和时间采用内建类型而不是字符串
    2. 用整型存储IP, 32位无符号整数

    ``` mysql
    mysql> SELECT INET_ATON('183.192.85.89');
    +----------------------------+
    | INET_ATON('183.192.85.89') |
    +----------------------------+
    |                 3082835289 |
    +----------------------------+
    1 row in set (0.00 sec)

    mysql> SELECT INET_NTOA('3082835289');
    +-------------------------+
    | INET_NTOA('3082835289') |
    +-------------------------+
    | 183.192.85.89           |
    +-------------------------+
    1 row in set (0.00 sec)
    ```

- 尽量避免NULL

> datetime 和 timestamp 可以存储相同类型的数据：时间和日期（精确到秒），然而timestamp只是用datetime一半的存储空间，并且根据时区变化，具有特殊的自动更新能力。
然而，timestamp允许的时间范围要小的多。

MySQL为了兼容性支持很多别名，e.g. integer,bool,numeric

#### 整数类型
tinyint(8 bit),smallint(16),mediumint(24),int(32),bigint(64）   
unsigned可选

> 整数计算一般使用64位bigint(一些聚合函数使用decimal/double)

#### 实数类型

float(4 bytes)和double(8 bytes)使用标准的浮点运算进行近似计算（CPU直接支持原生浮点计算，所以更快）；
MySQL服务器自身实现了decimal的高精度计算

#### 字符串

varchar,使用额外的一到两个byte记录字符串长度

char,删除所有末尾的空格

> char(10), 字符串长度定义不是字节数，而是字符数。

binary/varbinary, 存储二进制字符串，二进制比较比字符串比较快得多

> 使用varchar(5) 和 varchar(200)，空间开销是一样的，但是更长的列消耗更多的内存

#### BLOB & TEXT

字符类型：tinytext,smalltext(text),mediumtext,longtext

二进制类型：tinyblob,smallblob(blob),mediumblob,longblob

> 当blog和text值太大时，InnoDB使用专门的“外部”存储区域来进行存储，行内存放1～4bytes的指针。

隐式临时表，max_heap_table_size, tmp_table_size

#### ENUM 代替字符串

``` mysql
mysql> CREATE TABLE enum_test(  e ENUM('fish','apple','dog') NOT NULL);
Query OK, 0 rows affected (0.03 sec)

mysql> INSERT INTO enum_test(e) VALUES('fish'),('dog'),('apple');
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> select * from enum_test;
+-------+
| e     |
+-------+
| fish  |
| dog   |
| apple |
+-------+
3 rows in set (0.00 sec)

mysql> select e+0 from enum_test;
+-----+
| e+0 |
+-----+
|   1 |
|   3 |
|   2 |
+-----+
3 rows in set (0.00 sec)
```
三行数据实际存储为整数而不是字符串（排序按照整数）
枚举最不好的地方是，字符串列表是固定的，修改必须alter table(>=5.1, 只可以在列表末尾添加元素

#### 日期时间
datetime, 1001年到9999年，8 bytes

timestamp, 1970年1月1日到2038年，4 bytes,
from_unixtime(), unix_timestamp()

#### 位
- BIT，1～64 true/false
- SET

### schema 设计的陷阱
1. 太多的列，存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各列（代价高）
2. 太多的关联，所谓的”实体-属性-值“（EVA），【经验】：单个查询最好在12个表以内做关联
3. 枚举的使用
4. 表示未知值不要害怕使用NULL(MySQL会在索引中存储NULL值，而Oracle则不会）

### 范式，反范式
范式化的好处：
- 更新快
- 只有很少/没有重复数据
- 表通常更小
缺点： 关联

“缓存表“来表示存储那些可以比较简单地从schema其他表获取（但是每次获取的速度比较慢）数据的表
"汇总表“使用GROUP BY 聚合的表
重建这两种表时通常需要保证数据在操作时依然可用，通过"影子表"实现，
``` sql
DROP TABLE IF EXISTS my_summary_new, my_summary_old;
CREATE TABLE my_summary_new LIKE my_summary;
RENAME TABLE my_summary TO my_summary_old, my_summary_new TO my_summary;
```

物化视图,预先计算并且存储在磁盘上的表（Oracle, SQL Server），可以通过各种各样的策略刷新和更新

相比传统的维护“缓存表”和“汇总表”的方法，Flexviews通过提取对源表的更改，可以增量地计算物化视图的内容

### ALTER TABLE

1. 数据库切换
2. “影子表”
3. 不是所有的ALTER TABLE操作都会引起表重建
    ``` sql
    ALTER TABLE xxx
    MODIFY COLUMN xxx TINYINT(3) NOT NULL DEFAULT 5;
    -- SHOW STATUS 显示拷贝了整张表到一张新表
    ALTER TABLE xxx
    ALTER COLUMN xxx SET DEFAULT 5;
    -- 直接修改.frm文件，不涉及表数据 
    ```

### 快速创建MyISAM索引
（对唯一索引无效，MyISAM会在内存中构造唯一索引）为了高效载入数据到MyISAM表，先禁用索引载入数据，再重启索引
``` sql
ALTER TABLE xxx DISABLE KEYS;
-- load data
ALTER TABLE xxx ENABLE KEYS;
```

## 5.创建高性能的索引
索引（MySQL中也叫KEY）是存储引擎用于快速找到记录的一种数据结构。

1. 减少服务器需要扫描的数据量
2. 避免排序和和临时表
3. 将随机I/O变成顺序I/O 

#### B-Tree 索引
存储引擎以不同的方式使用B-Tree索引
![]({{ site.url }}/assets/high_performance_mysql_2.jpg)

#### 哈希索引

#### 空间数据索引 R-Tree
MySQL对GIS的支持不够完善，开源数据库中PostgreSQL做得比较好

#### 全文索引

#### 其他索引
TokuDB 使用分形树索引（fractal tree index)
...

### 高性能索引策略

three-star system:
索引将相关记录放到一起，一星
索引中的数据顺序和查找中的排列顺序一致，二星
索引中的列包含了查询中需要的全部列，三星

- 独立的列，索引列不能是表达式的一部分，也不能是函数的参数
- 前缀索引和索引的选择性(无法GROUP BY/ORDER BY，覆盖扫描(索引包含查询列)）
- 多列索引
- 选择合适的索引列顺序

### cluster index 聚簇索引
叶子页存放数据行，InnoDB使用主键作为聚簇索引,如果没有主键，选择一个唯一非空索引代替，如果没有这样的索引，隐式定义一个主键（rowid）來作为聚簇索引

二级索引先找到行的主键值，在去聚簇索引中找到对应的行

## 6.查询优化

1. 优化数据访问
    - 是否请求了不需要的数据
    - 是否在扫描额外的记录，衡量查询开销的三个指标：
        1. 响应时间(=服务时间+排队时间）
        2. 扫描的行数
        3. 返回的行数
            > EXPLAIN type:(从慢到快）全表扫描，索引扫描，范围，唯一索引查询，常数引用等
2. 重构查询的方式
    - 一个复杂查询还是多个简单查询
    - 切分查询,`DELETE FROM messages WHERE created < DATE_SUB(NOW(),INTERVAL 3 MONTH);`
    - 分解关联查询

![]({{ site.url }}/assets/high_performance_mysql_3.jpg)

多数连接MySQL的库函数从MySQL获取数据时，实际从库函数的缓存中获取数据。
通常情况下没有问题，但是如果要返回一个很大的结果集，库函数会花费很多时间和内存来缓存数据。
MySQL通常需要等所有的数据都发送给客户端才能释放这条查询所占用的资源。

``` php
<?php
$link = mysql_connect('localhost','user','pswd');
$result = mysql_query('SELECT * FROM xxx',$link);
while ( $row = mysql_fetch_array($result) ) {
    // do something
}
?>

<?php
$link = mysql_connect('localhost','user','pswd');
$result = mysql_unbuffered_query('SELECT * FROM xxx',$link);
while ( $row = mysql_fetch_array($result) ) {
    // do something
}
?>
```
查询状态
``` mysql
mysql> show full processlist;
+----+------+-----------+------+---------+------+----------+-----------------------+
| Id | User | Host      | db   | Command | Time | State    | Info                  |
+----+------+-----------+------+---------+------+----------+-----------------------+
|  8 | root | localhost | NULL | Query   |    0 | starting | show full processlist |
|  9 | root | localhost | NULL | Sleep   |    2 |          | NULL                  |
+----+------+-----------+------+---------+------+----------+-----------------------+
```
如果对某个查询执行EXPLAIN EXTENDED后，再执行SHOW WARNINGS，既可以看到重构出的查询。

查询优化器hint
- HIGH_PRIORITY/LOW_PRIORITY
- DELAYED
- STRAIGHT_JOIN
- SQL_SMALL_RESULT/SQL_BIG_RESULT
- SQL_BUFFER_RESULT
- SQL CACHE/SQL_NOCACHE
- SQL_CALC_FOUND_ROWS
- FOR UPDATE/LOCK IN SHARE MODE
- USE INDEX/IGNORE INDEX/FORCE INDEX
